Level 1 – Warmups (Core JS, Objects, Arrays)
1.	Deep Flatten Object (dot-notation keys)
Goal: Convert nested object to flat { "a.b.c": value }.
Input: 
const obj = { a: { b: { c: 10 } }, d: 5 };
Output:
{ "a.b.c": 10, "d": 5 }
Extensions: Support arrays (a[0].b), preserve types, allow custom separators.
2.	Invert Object with Collisions
Goal: Invert keys/values; if multiple keys share same value, group them in an array. 
Input: { a: 1, b: 2, c: 1 } 
Output: { "1": ["a", "c"], "2": ["b"] } 
Extensions: Handle non-primitive values safely with a custom serializer.
3.	Stable Unique by Key
•	Goal: Deduplicate array of objects by a key, preserving first occurrence order.
•	Input: [{id:1,a:10},{id:2,a:20},{id:1,a:30}]
•	Output: [{id:1,a:10},{id:2,a:20}]
•	Extensions: Allow multiple keys (['id','tenantId']).
4.	Group By with Aggregations
•	Goal: Group array by key and compute aggregates (count, sum, avg).
•	Input: [ {dept:'Eng', sal:10}, {dept:'HR', sal:5}, {dept:'Eng', sal:20} ]
•	Output: { Eng: { count:2, sum:30, avg:15 }, HR: { count:1, sum:5, avg:5 } }
•	Extensions: Pluggable aggregations via callbacks.


5.	Partition Array
•	Goal: Split array by predicate into [pass, fail].
•	Input: [1,2,3,4] with predicate x%2===0
•	Output: [[2,4],[1,3]]
•	Extensions: Multi-bucket classification.

Level 2 – Recursion, Transformations, Regex
1.	Deep Merge with Custom Strategy
•	Goal: Merge objects recursively; arrays can concat, replace, or unique.
•	Input: {a:{x:1, arr:[1]}} + {a:{y:2, arr:[1,2]}}
•	Output (concat strategy): {a:{x:1,y:2,arr:[1,1,2]}}
•	Extensions: Conflict resolver for same keys (left wins, right wins, merge).
2.	JSON Schema-based Mapper
•	Goal: Map nested input to output using a declarative path schema.
•	Schema Example:
const schema = {
  id: 'transaction.id',
  amount: 'transaction.value.amount',
  currency: 'transaction.value.currencyCode',
  status: (src) => src.transaction.state.toLowerCase()
};
•	Output: {id, amount, currency, status} 
•	Extensions: Handle arrays with [*], optional chaining, defaults.
3.	Validate and Mask Sensitive Fields
•	Goal: Mask PII (email, phone, card) in any nested object.
•	Input: { user:{ email:'a@b.com', phone:'9876543210', card:'4111111111111111' } }
•	Output: { user:{ email:'a***@b.com', phone:'******3210', card:'************1111' } }
•	Extensions: Configurable mask rules; preserve formats.
4.	Template Engine (Mini)
•	Goal: Replace {{path.to.value}} with actual values from an object.
•	Input: Template "Hi {{user.name}}, balance {{wallet.amount}}"
•	Output: "Hi Soumik, balance 250"
•	Extensions: Filters: {{user.name|uppercase}}, defaults: {{x||'N/A'}}.
5.	Version/Range Parser
•	Goal: Parse semver-like strings and compare 1.2.3 vs ^1.2.x.
•	Input: '1.2.3' vs '^1.2.0'
•	Output: true/false
•	Extensions: Support pre-releases, build metadata, sorting.

Level 3 – Async, Streaming, Performance
1.	Async Concurrency Controller
o	Goal: Given list of async tasks, run with max concurrency k.
o	Input: [task1, task2, ...], k=3
o	Output: Preserved order of results.
o	Extensions: Timeout per task, retry policy with backoff.
2.	Rate Limiter (Token Bucket)
o	Goal: Allow N requests per time window; burst capacity with tokens.
o	Input: limit=10/min, burst=5
o	Output: Function canProceed() returning boolean/timeToWait.
o	Extensions: Multi-tenant keys, memory + Redis adapter.
3.	Node Streams: CSV → JSON Transformer
o	Goal: Stream parse a large CSV, map fields, write JSON lines.
o	Input: id,name,amount\n1,Alice,10\n2,Bob,20
o	Output: {"id":1,"name":"Alice","amount":10}\n...
o	Extensions: Validate rows, backpressure handling, metrics.
4.	Memoization with Cache Eviction
o	Goal: Memoize pure function with LRU eviction.
o	Input: fib(n) or heavy hash()
o	Output: Speedup with limited cache size.
o	Extensions: TTL expiry, async function support.
5.	Diff & Patch Engine
o	Goal: Compute structural diff between two nested objects, produce patch ops.
o	Input: before, after
o	Output: Ops like {op:'replace', path:'a.b', value:3}
o	Extensions: Apply patch, conflict detection, array ops.
Level 4 – Functional Patterns, Immutability, Types
1.	Immutable Update Utility (Lens-like)
o	Goal: Update deep path immutably: update(obj, 'a.b.c', (v)=>v+1)
o	Input: {a:{b:{c:1}}}
o	Output: {a:{b:{c:2}}} (no mutation)
o	Extensions: Multiple updates in one pass; TypeScript path safety.
2.	Pipeline/Compose with Async Support
o	Goal: compose(f, g, h) with sync/async mixing.
o	Input: Functions like sanitize → validate → persist
o	Output: A single composed function.
o	Extensions: Error boundary per stage, tracing hooks.
3.	Event Emitter with Once, Off, Wildcards
o	Goal: Implement on, once, emit, off, wildcard user.*
o	Extensions: Async listeners, priority ordering, backpressure.
4.	Schema Validation (Mini Zod)
o	Goal: Build a tiny validator: string().min(3).email(), object({...})
o	Output: Parse result with errors and safe values.
o	Extensions: Refinements, union types, TypeScript inference.
5.	Router Path Matcher (Express-like)
o	Goal: Match routes with params and constraints: /users/:id(\\d+)/orders/:orderId
o	Input: /users/123/orders/abc
o	Output: { id: 123, orderId: 'abc' } or 404
o	Extensions: Optional segments, query parsing, middleware stack.

